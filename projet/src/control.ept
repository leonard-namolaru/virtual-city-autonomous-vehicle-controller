(* open Globals importe tous les éléments du module Globals, 
 * ce qui permet de les utiliser sans utiliser la préfixe "Globals." *)
open Globals

(* Pour l’intégration, on suppose que notre intégrale est échantillonné tous les dt instants. 
 * Si dt est très petit, ca nous donne une bonne approximation de l’intégrale. 
 * On fait une hypothèse sur la variation du signal qu’on intègre : dans notre code dt est fixe. *)
const dt : float = 0.01

(* **************************************** DEBUG **************************************** *)

(* Le fichier globals.ept définit le type itielt : type itielt = { act : action; param : float }
 * et fournit la fonction suivante : dbg_action(msg : string; act : action)
 * Mais cette fonction ne permet pas d'imprimer à la fois le type d'opération et la valeur du paramètre sur la même ligne. 
 * A cet effet, la fonction suivante a été écrite :   *)
fun dbg_itielt(msg : string; iti : itielt) returns ()
var w0, w1, w2, w3 : Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);

  switch iti.act
  | Go do w1 = Debug.d_string(w0, "Go ");
  | Turn do w1 = Debug.d_string(w0, "Turn ");
  | Stop do w1 = Debug.d_string(w0, "Stop ");
  end;

  w2 = Debug.d_float(w1, iti.param);
  w3 = Debug.d_string(w2, "\n");
tel

(* La fonction dbg_pid() permet d'imprimer sur une même ligne tous les coefficients utilisés pour le calcul du pid *)
fun dbg_pid(msg : string; kp, ki, kd : float) returns ()
var w0, w1, w2, w3, w4, w5, w6, w7 : Debug.world;
let
  w0 = Debug.d_string(Debug.d_init(), msg);

  w1 = Debug.d_string(w0, "kp = ");
  w2 = Debug.d_float(w1, kp);
  w3 = Debug.d_string(w2, " ki = ");
  w4 = Debug.d_float(w3, ki);
  w5 = Debug.d_string(w4, " kd = ");
  w6 = Debug.d_float(w5, kd);

  w7 = Debug.d_string(w6, "\n");
tel

(* **************************************** PID **************************************** *)

(* PID controller : proportional–integral–derivative controller
 * La fonction pid_controller() reçoit comme paramètres les valeurs error et pre_error, qui représentent, respectivement,
 * le taux d'erreur à l'instant courant, et le taux d'erreur à l'instant précédent. 
 * De plus, cette fonction reçoit les coefficients requis pour le calcul du pid *)
node pid_controller(pre_error, error : float; kp, ki, kd : float) returns (y : float)
let
  y =   kp *. error +.  ki *. Utilities.integrator(error, dt, pre_error) +. kd *. Utilities.derivative(error, dt);
tel

(* Sources : https://www.arnabkumardas.com/platforms/everything-esp/esp32-qtr-8rc-pid-line-follower-robot-v1/ , Trial and Error Method 
 *           https://towardinfinity.medium.com/pid-for-line-follower-11deb3a1a643 *)
node trial_and_error(max_speed, error : float) returns (kp, ki, kd : float)
var ki_determined, kd_determined : bool;
    pre_ki, pre_kd, pre_pre_ki, pre_pre_kd : float;
let
  pre_ki = 0.0 fby ki;
  pre_kd = 0.0 fby kd;

  pre_pre_ki = 1.0 fby pre_ki;
  pre_pre_kd = 1.0 fby pre_kd;

  ki_determined = false -> if pre_ki = pre_pre_ki and error <> 0.0 then true else (pre ki_determined);
  kd_determined = false -> if pre_kd = pre_pre_kd and error <> 0.0 then true else (pre kd_determined);

  kp = 0.0 -> max_speed;
  ki = 0.0 -> if (not ki_determined and kd_determined and error = 0.0) or (kd_determined <> false fby kd_determined) then (pre ki) +. 1.0 else (pre ki);
  kd = 0.0 -> if (not kd_determined and error = 0.0) then (pre kd) +. 1.0 else (pre kd);
tel

(* **************************************** COLOR COMPARISON **************************************** *)
(* Source : https://observablehq.com/@luciyer/euclidian-distance-in-rgb-color-space *)

fun pow_exponent_two(num : int) returns (result : int)
let
  result = num * num;
tel

fun pow_difference_rgb_component(rgb_component1, rgb_component2 : int) returns (result : float)
let
  result = Mathext.float( pow_exponent_two( rgb_component2 - rgb_component1 ) );
tel

node euclidian_distance_rgb_color(color1, color2 : color) returns (d : float)
let
  d = Mathext.sqrt( pow_difference_rgb_component(color2.green, color1.green)
                 +. pow_difference_rgb_component(color2.red, color1.red) 
                 +. pow_difference_rgb_component(color2.blue, color1.blue) );
tel

(* **************************************** SPEED **************************************** *)

fun speed_pid(pid, actual_speed : float) returns (speed : float)
let
  speed = actual_speed -. Utilities.abs(pid);
tel

node get_rspeed(iti : itielt; error, in_red, pid, actual_speed : float) returns (rspeed : wheels)
var d:float;t:int;
let
  d = ((2.0 *. Globals.pi *. Globals.cB)/. 100.0) /. (360.0 /. (iti.param));
  t = Mathext.int(actual_speed *. d);
  switch iti.act
  | Go do rspeed = if error >. 0.0  then { left = speed_pid(pid, actual_speed) ; right = actual_speed }
                   else                  { left = actual_speed ; right = speed_pid(pid, actual_speed)};
  | Turn do  rspeed = if Utilities.countdown(true, 37) > 0 then (if iti.param >. 0.0 then { left = 0.0 ; right = actual_speed} else {left = actual_speed ; right = 0.0})
                      else if error >. 0.0  then { left = speed_pid(pid, actual_speed) ; right = actual_speed }
                      else                  { left = actual_speed ; right = speed_pid(pid, actual_speed)};
  | Stop do rspeed = { left = 0.0; right = 0.0};
  end;

tel

(* **************************************** CONTROLLER **************************************** *)

node controller(sens : sensors; iti : itielts) returns (rspeed : wheels; arriving : bool)
var last i : int=0; last action : action = Go;
    actual_speed, in_red, in_green, error, pre_error, pid, kp, ki, kd : float;
let
  
  in_red =  Mathext.float(sens.s_road.red) /. 255.0;
  in_green =  Mathext.float(sens.s_road.green) /. 255.0;
  error = if sens.s_road.red = 255 and sens.s_road.blue = 0 then 0.0
          else euclidian_distance_rgb_color( { red = 0; green = 0; blue = 255 }, sens.s_road) /. 255.0 *. (if in_green >. in_red then -. 1.0 else 1.0);

  actual_speed =   if sens.s_front.red = 255 and sens.s_road.red = 255 and sens.s_road.blue = 0 then 0.0
                   else if (iti[>i<]).act = Go then (iti[>i<]).param *. 360.0 *. Globals.cD /. 100.0 else (0.0 fby actual_speed);
                   
  (kp, ki, kd) = trial_and_error(actual_speed, error);
  pid = pid_controller(pre_error, error, kp, ki, kd); 
  pre_error = 0.0 fby error;

  automaton
    state Go
      do
        i = if (sens.s_road.green = 255 and sens.s_road.blue = 0 and (0 fby sens.s_road.green) < 255) then (last i+1) else (last i);
        action = (iti[>i<]).act;
        arriving = action = Stop;
        rspeed =  get_rspeed(iti[>i<], error, in_red, pid, actual_speed);
      until (iti[>i<]).act = Turn then Turn
      
    state Turn
      var x : int;
      do 
        x = Utilities.countdown(true, 37);
        i = if(x>0) then last i else (last i+1);
        action = (iti[>i<]).act;
        arriving = action = Stop;
        rspeed =  get_rspeed(iti[>i<], error, in_red, pid, actual_speed);
      until (iti[>i<]).act = Go then Go
  end;

 
  
  () = Debug.dbg_int("i = ", i);
  () = dbg_itielt("iti[i] : ", iti[>i<]);
tel


